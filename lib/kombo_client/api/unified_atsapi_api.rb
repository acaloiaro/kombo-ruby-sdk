=begin
#Kombo API

#No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
Generator version: 7.17.0

=end

require 'cgi'

module Kombo
  class UnifiedATSAPIApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Remove tag from candidate
    # Remove a tag from a candidate based on its name.  This will also succeed if the tag does not exist on the candidate.  <Note>   This endpoint requires the permission **Manage tags** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"tag\": {     \"name\": \"Excellent Fit\"   } } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to remove the tag from.
    # @param [Hash] opts the optional parameters
    # @option opts [DeleteAtsCandidatesCandidateIdTagsRequestBody] :delete_ats_candidates_candidate_id_tags_request_body DELETE /ats/candidates/:candidate_id/tags Request body
    # @return [DeleteAtsCandidatesCandidateIdTagsPositiveResponse]
    def delete_ats_candidates_candidate_id_tags(x_integration_id, candidate_id, opts = {})
      data, _status_code, _headers = delete_ats_candidates_candidate_id_tags_with_http_info(x_integration_id, candidate_id, opts)
      data
    end

    # Remove tag from candidate
    # Remove a tag from a candidate based on its name.  This will also succeed if the tag does not exist on the candidate.  &lt;Note&gt;   This endpoint requires the permission **Manage tags** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;tag\&quot;: {     \&quot;name\&quot;: \&quot;Excellent Fit\&quot;   } } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to remove the tag from.
    # @param [Hash] opts the optional parameters
    # @option opts [DeleteAtsCandidatesCandidateIdTagsRequestBody] :delete_ats_candidates_candidate_id_tags_request_body DELETE /ats/candidates/:candidate_id/tags Request body
    # @return [Array<(DeleteAtsCandidatesCandidateIdTagsPositiveResponse, Integer, Hash)>] DeleteAtsCandidatesCandidateIdTagsPositiveResponse data, response status code and response headers
    def delete_ats_candidates_candidate_id_tags_with_http_info(x_integration_id, candidate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.delete_ats_candidates_candidate_id_tags ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.delete_ats_candidates_candidate_id_tags"
      end
      # verify the required parameter 'candidate_id' is set
      if @api_client.config.client_side_validation && candidate_id.nil?
        fail ArgumentError, "Missing the required parameter 'candidate_id' when calling UnifiedATSAPIApi.delete_ats_candidates_candidate_id_tags"
      end
      # resource path
      local_var_path = '/ats/candidates/{candidate_id}/tags'.sub('{' + 'candidate_id' + '}', CGI.escape(candidate_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'delete_ats_candidates_candidate_id_tags_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'DeleteAtsCandidatesCandidateIdTagsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.delete_ats_candidates_candidate_id_tags",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#delete_ats_candidates_candidate_id_tags\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @return [GetAtsActionsAtsAddApplicationAttachmentPositiveResponse]
    def get_ats_actions_ats_add_application_attachment(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_actions_ats_add_application_attachment_with_http_info(x_integration_id, opts)
      data
    end

    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetAtsActionsAtsAddApplicationAttachmentPositiveResponse, Integer, Hash)>] GetAtsActionsAtsAddApplicationAttachmentPositiveResponse data, response status code and response headers
    def get_ats_actions_ats_add_application_attachment_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_actions_ats_add_application_attachment ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_actions_ats_add_application_attachment"
      end
      # resource path
      local_var_path = '/ats/actions/ats_add_application_attachment'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsActionsAtsAddApplicationAttachmentPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_actions_ats_add_application_attachment",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_actions_ats_add_application_attachment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @return [GetAtsActionsAtsAddCandidateAttachmentPositiveResponse]
    def get_ats_actions_ats_add_candidate_attachment(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_actions_ats_add_candidate_attachment_with_http_info(x_integration_id, opts)
      data
    end

    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetAtsActionsAtsAddCandidateAttachmentPositiveResponse, Integer, Hash)>] GetAtsActionsAtsAddCandidateAttachmentPositiveResponse data, response status code and response headers
    def get_ats_actions_ats_add_candidate_attachment_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_actions_ats_add_candidate_attachment ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_actions_ats_add_candidate_attachment"
      end
      # resource path
      local_var_path = '/ats/actions/ats_add_candidate_attachment'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsActionsAtsAddCandidateAttachmentPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_actions_ats_add_candidate_attachment",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_actions_ats_add_candidate_attachment\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @return [GetAtsActionsAtsCreateApplicationPositiveResponse]
    def get_ats_actions_ats_create_application(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_actions_ats_create_application_with_http_info(x_integration_id, opts)
      data
    end

    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetAtsActionsAtsCreateApplicationPositiveResponse, Integer, Hash)>] GetAtsActionsAtsCreateApplicationPositiveResponse data, response status code and response headers
    def get_ats_actions_ats_create_application_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_actions_ats_create_application ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_actions_ats_create_application"
      end
      # resource path
      local_var_path = '/ats/actions/ats_create_application'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsActionsAtsCreateApplicationPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_actions_ats_create_application",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_actions_ats_create_application\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @return [GetAtsActionsAtsCreateCandidatePositiveResponse]
    def get_ats_actions_ats_create_candidate(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_actions_ats_create_candidate_with_http_info(x_integration_id, opts)
      data
    end

    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetAtsActionsAtsCreateCandidatePositiveResponse, Integer, Hash)>] GetAtsActionsAtsCreateCandidatePositiveResponse data, response status code and response headers
    def get_ats_actions_ats_create_candidate_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_actions_ats_create_candidate ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_actions_ats_create_candidate"
      end
      # resource path
      local_var_path = '/ats/actions/ats_create_candidate'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsActionsAtsCreateCandidatePositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_actions_ats_create_candidate",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_actions_ats_create_candidate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get application stages
    # Get all application stages available in the ATS.  <Warning>   **This endpoint is deprecated!**    Get all application stages available in the ATS. This is deprecated because most ATS systems have separate sets of stages for each job. We'd recommend using the `stages` property from the [GET Jobs endpoint](/ats/v1/get-jobs) instead.  **Important**: Using global stages can cause \"Stage not found\" errors when moving applications, especially with systems like Workable that have job-specific stages.  [Moving Applications Guide](/ats/implementation-guide/moving-and-rejecting-candidates). </Warning>  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsApplicationStagesParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @return [GetAtsApplicationStagesPositiveResponse]
    def get_ats_application_stages(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_application_stages_with_http_info(x_integration_id, opts)
      data
    end

    # Get application stages
    # Get all application stages available in the ATS.  &lt;Warning&gt;   **This endpoint is deprecated!**    Get all application stages available in the ATS. This is deprecated because most ATS systems have separate sets of stages for each job. We&#39;d recommend using the &#x60;stages&#x60; property from the [GET Jobs endpoint](/ats/v1/get-jobs) instead.  **Important**: Using global stages can cause \&quot;Stage not found\&quot; errors when moving applications, especially with systems like Workable that have job-specific stages.  [Moving Applications Guide](/ats/implementation-guide/moving-and-rejecting-candidates). &lt;/Warning&gt;  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsApplicationStagesParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @return [Array<(GetAtsApplicationStagesPositiveResponse, Integer, Hash)>] GetAtsApplicationStagesPositiveResponse data, response status code and response headers
    def get_ats_application_stages_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_application_stages ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_application_stages"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_application_stages, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_application_stages, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_application_stages, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/application-stages'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsApplicationStagesPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_application_stages",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_application_stages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get applications
    # Retrieve all applications.  Visit our in-depth guides to learn more about:  - üí° [Being aware of which applications are tracked](/ats/features/implementation-guide/tracking-created-applications#be-aware-of-which-applications-are-tracked) - üö¶ [Hiring signals](/ats/features/implementation-guide/tracking-created-applications#hiring-signals) - üìà [Application stage changes](/ats/features/implementation-guide/tracking-created-applications#application-stage-changes) - ‚ùì [ATS-specific limitations](/ats/features/implementation-guide/tracking-created-applications#ats-specific-limitations)  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsApplicationsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [GetAtsApplicationsParameterOutcome] :outcome **(‚ö†Ô∏è Deprecated - Use the &#x60;outcomes&#x60; filter instead.)** Filter applications by outcome. This allows you to get applications that are for example &#x60;PENDING&#x60;, &#x60;HIRED&#x60;, or &#x60;DECLINED&#x60;.
    # @option opts [String] :outcomes Filter by a comma-separated list of &#x60;PENDING&#x60;, &#x60;HIRED&#x60;, &#x60;DECLINED&#x60;  * &#x60;PENDING&#x60;: The application is still being processed.  * &#x60;HIRED&#x60;: The candidate was hired.  * &#x60;DECLINED&#x60;: The candidate was declined.     Leave this blank to get results matching all values.
    # @option opts [String] :job_ids Filter by a comma-separated list of job IDs. We will only return applications that are related to _any_ of the jobs.
    # @option opts [String] :job_remote_ids Filter by a comma-separated list of job remote IDs. We will only return applications that are related to _any_ of the jobs.
    # @option opts [String] :current_stage_ids Filter by a comma-separated list of application stage IDs. We will only return applications that are currently in _any_ of the stages.
    # @option opts [Time] :remote_created_after Filter applications by the day they were created in the remote system. This allows you to get applications that were created on or after a certain day.
    # @return [GetAtsApplicationsPositiveResponse]
    def get_ats_applications(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_applications_with_http_info(x_integration_id, opts)
      data
    end

    # Get applications
    # Retrieve all applications.  Visit our in-depth guides to learn more about:  - üí° [Being aware of which applications are tracked](/ats/features/implementation-guide/tracking-created-applications#be-aware-of-which-applications-are-tracked) - üö¶ [Hiring signals](/ats/features/implementation-guide/tracking-created-applications#hiring-signals) - üìà [Application stage changes](/ats/features/implementation-guide/tracking-created-applications#application-stage-changes) - ‚ùì [ATS-specific limitations](/ats/features/implementation-guide/tracking-created-applications#ats-specific-limitations)  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsApplicationsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [GetAtsApplicationsParameterOutcome] :outcome **(‚ö†Ô∏è Deprecated - Use the &#x60;outcomes&#x60; filter instead.)** Filter applications by outcome. This allows you to get applications that are for example &#x60;PENDING&#x60;, &#x60;HIRED&#x60;, or &#x60;DECLINED&#x60;.
    # @option opts [String] :outcomes Filter by a comma-separated list of &#x60;PENDING&#x60;, &#x60;HIRED&#x60;, &#x60;DECLINED&#x60;  * &#x60;PENDING&#x60;: The application is still being processed.  * &#x60;HIRED&#x60;: The candidate was hired.  * &#x60;DECLINED&#x60;: The candidate was declined.     Leave this blank to get results matching all values.
    # @option opts [String] :job_ids Filter by a comma-separated list of job IDs. We will only return applications that are related to _any_ of the jobs.
    # @option opts [String] :job_remote_ids Filter by a comma-separated list of job remote IDs. We will only return applications that are related to _any_ of the jobs.
    # @option opts [String] :current_stage_ids Filter by a comma-separated list of application stage IDs. We will only return applications that are currently in _any_ of the stages.
    # @option opts [Time] :remote_created_after Filter applications by the day they were created in the remote system. This allows you to get applications that were created on or after a certain day.
    # @return [Array<(GetAtsApplicationsPositiveResponse, Integer, Hash)>] GetAtsApplicationsPositiveResponse data, response status code and response headers
    def get_ats_applications_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_applications ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_applications"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_applications, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_applications, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_applications, must conform to the pattern #{pattern}."
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'remote_created_after'].nil? && opts[:'remote_created_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"remote_created_after\"]' when calling UnifiedATSAPIApi.get_ats_applications, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/applications'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?
      query_params[:'outcome'] = opts[:'outcome'] if !opts[:'outcome'].nil?
      query_params[:'outcomes'] = opts[:'outcomes'] if !opts[:'outcomes'].nil?
      query_params[:'job_ids'] = opts[:'job_ids'] if !opts[:'job_ids'].nil?
      query_params[:'job_remote_ids'] = opts[:'job_remote_ids'] if !opts[:'job_remote_ids'].nil?
      query_params[:'current_stage_ids'] = opts[:'current_stage_ids'] if !opts[:'current_stage_ids'].nil?
      query_params[:'remote_created_after'] = opts[:'remote_created_after'] if !opts[:'remote_created_after'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsApplicationsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_applications",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_applications\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get application attachments
    # Get attachments from a candidate or application.  Get attachments from an application. If the ATS stores the attachments on the candidate, it will get the attachments from the corresponding candidate instead.  <Note>   This endpoint requires the permission **Read document attachments** to be enabled in [your scope config](/scopes). </Note>
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to obtain attachments for.
    # @param [Hash] opts the optional parameters
    # @return [GetAtsApplicationsApplicationIdAttachmentsPositiveResponse]
    def get_ats_applications_application_id_attachments(x_integration_id, application_id, opts = {})
      data, _status_code, _headers = get_ats_applications_application_id_attachments_with_http_info(x_integration_id, application_id, opts)
      data
    end

    # Get application attachments
    # Get attachments from a candidate or application.  Get attachments from an application. If the ATS stores the attachments on the candidate, it will get the attachments from the corresponding candidate instead.  &lt;Note&gt;   This endpoint requires the permission **Read document attachments** to be enabled in [your scope config](/scopes). &lt;/Note&gt;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to obtain attachments for.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetAtsApplicationsApplicationIdAttachmentsPositiveResponse, Integer, Hash)>] GetAtsApplicationsApplicationIdAttachmentsPositiveResponse data, response status code and response headers
    def get_ats_applications_application_id_attachments_with_http_info(x_integration_id, application_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_applications_application_id_attachments ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_applications_application_id_attachments"
      end
      # verify the required parameter 'application_id' is set
      if @api_client.config.client_side_validation && application_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_id' when calling UnifiedATSAPIApi.get_ats_applications_application_id_attachments"
      end
      # resource path
      local_var_path = '/ats/applications/{application_id}/attachments'.sub('{' + 'application_id' + '}', CGI.escape(application_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsApplicationsApplicationIdAttachmentsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_applications_application_id_attachments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_applications_application_id_attachments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get candidates
    # Retrieve all candidates.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsCandidatesParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [String] :email Filter the candidates based on an email address. When set, returns only the candidates where the given &#x60;email&#x60; is in &#x60;email_addresses&#x60;. This filter is case-insensitive.
    # @option opts [String] :job_ids Filter by a comma-separated list of job IDs. We will only return candidates that have applied to _any_ of the jobs.
    # @option opts [String] :first_name Filter candidates by first name. This filter is case-insensitive and matches the exact first name. Fuzzy matching might be enabled in the future, so consider this for your implementation.
    # @option opts [String] :last_name Filter candidates by last name. This filter is case-insensitive and matches the exact last name. Fuzzy matching might be enabled in the future, so consider this for your implementation.
    # @return [GetAtsCandidatesPositiveResponse]
    def get_ats_candidates(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_candidates_with_http_info(x_integration_id, opts)
      data
    end

    # Get candidates
    # Retrieve all candidates.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsCandidatesParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [String] :email Filter the candidates based on an email address. When set, returns only the candidates where the given &#x60;email&#x60; is in &#x60;email_addresses&#x60;. This filter is case-insensitive.
    # @option opts [String] :job_ids Filter by a comma-separated list of job IDs. We will only return candidates that have applied to _any_ of the jobs.
    # @option opts [String] :first_name Filter candidates by first name. This filter is case-insensitive and matches the exact first name. Fuzzy matching might be enabled in the future, so consider this for your implementation.
    # @option opts [String] :last_name Filter candidates by last name. This filter is case-insensitive and matches the exact last name. Fuzzy matching might be enabled in the future, so consider this for your implementation.
    # @return [Array<(GetAtsCandidatesPositiveResponse, Integer, Hash)>] GetAtsCandidatesPositiveResponse data, response status code and response headers
    def get_ats_candidates_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_candidates ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_candidates"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_candidates, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_candidates, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_candidates, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/candidates'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?
      query_params[:'email'] = opts[:'email'] if !opts[:'email'].nil?
      query_params[:'job_ids'] = opts[:'job_ids'] if !opts[:'job_ids'].nil?
      query_params[:'first_name'] = opts[:'first_name'] if !opts[:'first_name'].nil?
      query_params[:'last_name'] = opts[:'last_name'] if !opts[:'last_name'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsCandidatesPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_candidates",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_candidates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get candidate attachments
    # Get attachments from a candidate, including all attachments of all of their applications.  <Note>   This endpoint requires the permission **Read document attachments** to be enabled in [your scope config](/scopes). </Note>
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to obtain attachments for.
    # @param [Hash] opts the optional parameters
    # @return [GetAtsCandidatesCandidateIdAttachmentsPositiveResponse]
    def get_ats_candidates_candidate_id_attachments(x_integration_id, candidate_id, opts = {})
      data, _status_code, _headers = get_ats_candidates_candidate_id_attachments_with_http_info(x_integration_id, candidate_id, opts)
      data
    end

    # Get candidate attachments
    # Get attachments from a candidate, including all attachments of all of their applications.  &lt;Note&gt;   This endpoint requires the permission **Read document attachments** to be enabled in [your scope config](/scopes). &lt;/Note&gt;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to obtain attachments for.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetAtsCandidatesCandidateIdAttachmentsPositiveResponse, Integer, Hash)>] GetAtsCandidatesCandidateIdAttachmentsPositiveResponse data, response status code and response headers
    def get_ats_candidates_candidate_id_attachments_with_http_info(x_integration_id, candidate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_candidates_candidate_id_attachments ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_candidates_candidate_id_attachments"
      end
      # verify the required parameter 'candidate_id' is set
      if @api_client.config.client_side_validation && candidate_id.nil?
        fail ArgumentError, "Missing the required parameter 'candidate_id' when calling UnifiedATSAPIApi.get_ats_candidates_candidate_id_attachments"
      end
      # resource path
      local_var_path = '/ats/candidates/{candidate_id}/attachments'.sub('{' + 'candidate_id' + '}', CGI.escape(candidate_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsCandidatesCandidateIdAttachmentsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_candidates_candidate_id_attachments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_candidates_candidate_id_attachments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get interviews
    # Retrieve all interviews.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsInterviewsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [String] :job_ids Filter by a comma-separated list of job IDs. We will only return interviews for applications associated with any of these jobs.
    # @return [GetAtsInterviewsPositiveResponse]
    def get_ats_interviews(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_interviews_with_http_info(x_integration_id, opts)
      data
    end

    # Get interviews
    # Retrieve all interviews.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsInterviewsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [String] :job_ids Filter by a comma-separated list of job IDs. We will only return interviews for applications associated with any of these jobs.
    # @return [Array<(GetAtsInterviewsPositiveResponse, Integer, Hash)>] GetAtsInterviewsPositiveResponse data, response status code and response headers
    def get_ats_interviews_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_interviews ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_interviews"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_interviews, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_interviews, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_interviews, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/interviews'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?
      query_params[:'job_ids'] = opts[:'job_ids'] if !opts[:'job_ids'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsInterviewsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_interviews",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_interviews\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get jobs
    # Retrieve all jobs.  Visit our in-depth guides to learn more about:  - üîÑ [Getting updates of the data](/ats/features/implementation-guide/reading-jobs#getting-updates-of-the-data) - ‚ùó [Handling failing syncs](/ats/features/implementation-guide/reading-jobs#handling-failing-syncs) - üîç [Letting your customer choose which jobs to expose](/ats/features/implementation-guide/reading-jobs#let-your-customer-choose-which-jobs-to-expose-to-you) - üîó [Matching jobs in your database to ATS jobs](/ats/features/implementation-guide/reading-jobs#match-jobs-in-your-database-to-ats-jobs) - üóëÔ∏è [Reacting to deleted/closed jobs](/ats/features/implementation-guide/reading-jobs#reacting-to-deleted-closed-jobs)  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsJobsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [String] :job_codes Filter by a comma-separated list of job codes.
    # @option opts [String] :post_url Filter by the &#x60;post_url&#x60; field. Can be used to find a job based on its public posting URL.
    # @option opts [GetAtsJobsParameterStatus] :status **(‚ö†Ô∏è Deprecated - Use the &#x60;statuses&#x60; filter instead.)** Filter by the &#x60;status&#x60; field. Can be used to find a job based on its status.
    # @option opts [String] :statuses Filter by a comma-separated list of &#x60;OPEN&#x60;, &#x60;CLOSED&#x60;, &#x60;DRAFT&#x60;, &#x60;ARCHIVED&#x60;    Leave this blank to get results matching all values.
    # @option opts [String] :employment_types Filter by a comma-separated list of &#x60;FULL_TIME&#x60;, &#x60;PART_TIME&#x60;, &#x60;CONTRACT&#x60;, &#x60;SEASONAL&#x60;, &#x60;INTERNSHIP&#x60;    Leave this blank to get results matching all values.
    # @option opts [String] :visibilities Filter by a comma-separated list of &#x60;PUBLIC&#x60;, &#x60;INTERNAL&#x60;, &#x60;UNLISTED&#x60;, &#x60;CONFIDENTIAL&#x60;    Leave this blank to get results matching all values.
    # @option opts [Time] :remote_created_after Filter jobs by the day they were created in the remote system. This allows you to get jobs that were created on or after a certain day.
    # @option opts [String] :name_contains Filter by the &#x60;name&#x60; field. Can be used to find a job by keywords present in the job name.
    # @return [GetAtsJobsPositiveResponse]
    def get_ats_jobs(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_jobs_with_http_info(x_integration_id, opts)
      data
    end

    # Get jobs
    # Retrieve all jobs.  Visit our in-depth guides to learn more about:  - üîÑ [Getting updates of the data](/ats/features/implementation-guide/reading-jobs#getting-updates-of-the-data) - ‚ùó [Handling failing syncs](/ats/features/implementation-guide/reading-jobs#handling-failing-syncs) - üîç [Letting your customer choose which jobs to expose](/ats/features/implementation-guide/reading-jobs#let-your-customer-choose-which-jobs-to-expose-to-you) - üîó [Matching jobs in your database to ATS jobs](/ats/features/implementation-guide/reading-jobs#match-jobs-in-your-database-to-ats-jobs) - üóëÔ∏è [Reacting to deleted/closed jobs](/ats/features/implementation-guide/reading-jobs#reacting-to-deleted-closed-jobs)  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsJobsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [String] :job_codes Filter by a comma-separated list of job codes.
    # @option opts [String] :post_url Filter by the &#x60;post_url&#x60; field. Can be used to find a job based on its public posting URL.
    # @option opts [GetAtsJobsParameterStatus] :status **(‚ö†Ô∏è Deprecated - Use the &#x60;statuses&#x60; filter instead.)** Filter by the &#x60;status&#x60; field. Can be used to find a job based on its status.
    # @option opts [String] :statuses Filter by a comma-separated list of &#x60;OPEN&#x60;, &#x60;CLOSED&#x60;, &#x60;DRAFT&#x60;, &#x60;ARCHIVED&#x60;    Leave this blank to get results matching all values.
    # @option opts [String] :employment_types Filter by a comma-separated list of &#x60;FULL_TIME&#x60;, &#x60;PART_TIME&#x60;, &#x60;CONTRACT&#x60;, &#x60;SEASONAL&#x60;, &#x60;INTERNSHIP&#x60;    Leave this blank to get results matching all values.
    # @option opts [String] :visibilities Filter by a comma-separated list of &#x60;PUBLIC&#x60;, &#x60;INTERNAL&#x60;, &#x60;UNLISTED&#x60;, &#x60;CONFIDENTIAL&#x60;    Leave this blank to get results matching all values.
    # @option opts [Time] :remote_created_after Filter jobs by the day they were created in the remote system. This allows you to get jobs that were created on or after a certain day.
    # @option opts [String] :name_contains Filter by the &#x60;name&#x60; field. Can be used to find a job by keywords present in the job name.
    # @return [Array<(GetAtsJobsPositiveResponse, Integer, Hash)>] GetAtsJobsPositiveResponse data, response status code and response headers
    def get_ats_jobs_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_jobs ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_jobs"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_jobs, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_jobs, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_jobs, must conform to the pattern #{pattern}."
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'remote_created_after'].nil? && opts[:'remote_created_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"remote_created_after\"]' when calling UnifiedATSAPIApi.get_ats_jobs, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/jobs'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?
      query_params[:'job_codes'] = opts[:'job_codes'] if !opts[:'job_codes'].nil?
      query_params[:'post_url'] = opts[:'post_url'] if !opts[:'post_url'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'statuses'] = opts[:'statuses'] if !opts[:'statuses'].nil?
      query_params[:'employment_types'] = opts[:'employment_types'] if !opts[:'employment_types'].nil?
      query_params[:'visibilities'] = opts[:'visibilities'] if !opts[:'visibilities'].nil?
      query_params[:'remote_created_after'] = opts[:'remote_created_after'] if !opts[:'remote_created_after'].nil?
      query_params[:'name_contains'] = opts[:'name_contains'] if !opts[:'name_contains'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsJobsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_jobs",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_jobs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get offers
    # Retrieve all offers.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsOffersParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @return [GetAtsOffersPositiveResponse]
    def get_ats_offers(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_offers_with_http_info(x_integration_id, opts)
      data
    end

    # Get offers
    # Retrieve all offers.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsOffersParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @return [Array<(GetAtsOffersPositiveResponse, Integer, Hash)>] GetAtsOffersPositiveResponse data, response status code and response headers
    def get_ats_offers_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_offers ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_offers"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_offers, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_offers, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_offers, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/offers'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsOffersPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_offers",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_offers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get rejection reasons
    # Retrieve all rejection reasons.  Get all rejection reasons available in the system. The Kombo ID is required in the associated [reject application action](/ats/v1/post-applications-application-id-reject).  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsRejectionReasonsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @return [GetAtsRejectionReasonsPositiveResponse]
    def get_ats_rejection_reasons(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_rejection_reasons_with_http_info(x_integration_id, opts)
      data
    end

    # Get rejection reasons
    # Retrieve all rejection reasons.  Get all rejection reasons available in the system. The Kombo ID is required in the associated [reject application action](/ats/v1/post-applications-application-id-reject).  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsRejectionReasonsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @return [Array<(GetAtsRejectionReasonsPositiveResponse, Integer, Hash)>] GetAtsRejectionReasonsPositiveResponse data, response status code and response headers
    def get_ats_rejection_reasons_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_rejection_reasons ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_rejection_reasons"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_rejection_reasons, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_rejection_reasons, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_rejection_reasons, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/rejection-reasons'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsRejectionReasonsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_rejection_reasons",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_rejection_reasons\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get tags
    # Retrieve all tags.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsTagsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @return [GetAtsTagsPositiveResponse]
    def get_ats_tags(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_tags_with_http_info(x_integration_id, opts)
      data
    end

    # Get tags
    # Retrieve all tags.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsTagsParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @return [Array<(GetAtsTagsPositiveResponse, Integer, Hash)>] GetAtsTagsPositiveResponse data, response status code and response headers
    def get_ats_tags_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_tags ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_tags"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_tags, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_tags, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_tags, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/tags'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsTagsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_tags",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_tags\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get users
    # Retrieve all users.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: `(id IN ids) AND (remote_id IN remote_ids)`
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsUsersParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [String] :emails Filter by a comma-separated list of emails. We will only return users who have _any_ of the emails. The format of the emails is case-insensitive.
    # @return [GetAtsUsersPositiveResponse]
    def get_ats_users(x_integration_id, opts = {})
      data, _status_code, _headers = get_ats_users_with_http_info(x_integration_id, opts)
      data
    end

    # Get users
    # Retrieve all users.  Top level filters use AND, while individual filters use OR if they accept multiple arguments. That means filters will be resolved like this: &#x60;(id IN ids) AND (remote_id IN remote_ids)&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cursor An optional cursor string used for pagination. This can be retrieved from the &#x60;next&#x60; property of the previous page response.
    # @option opts [Integer] :page_size The number of results to return per page. Maximum is 250. (default to 100)
    # @option opts [Time] :updated_after Filter the entries based on the modification date in format &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60;. Returns records where either the record itself **OR** its nested data has been updated since this timestamp, even if the record&#39;s own &#x60;changed_at&#x60; field remains unchanged.  If you want to track entry deletion, also set the &#x60;include_deleted&#x3D;true&#x60; query parameter, because otherwise, deleted entries will be hidden.  For more details, see [Understanding changed_at vs updated_after Behavior](https://docs.kombo.dev/ats/getting-started/fetching-data#understanding-changed_at-vs-updated_after-behavior).
    # @option opts [GetAtsUsersParameterIncludeDeleted] :include_deleted By default, deleted entries are not returned. Use the &#x60;include_deleted&#x60; query param to include deleted entries too. (default to 'false')
    # @option opts [String] :ids Filter by a comma-separated list of IDs such as &#x60;222k7eCGyUdgt2JWZDNnkDs3,B5DVmypWENfU6eMe6gYDyJG3&#x60;.
    # @option opts [String] :remote_ids Filter by a comma-separated list of remote IDs.
    # @option opts [String] :emails Filter by a comma-separated list of emails. We will only return users who have _any_ of the emails. The format of the emails is case-insensitive.
    # @return [Array<(GetAtsUsersPositiveResponse, Integer, Hash)>] GetAtsUsersPositiveResponse data, response status code and response headers
    def get_ats_users_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.get_ats_users ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.get_ats_users"
      end
      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] > 250
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_users, must be smaller than or equal to 250.'
      end

      if @api_client.config.client_side_validation && !opts[:'page_size'].nil? && opts[:'page_size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"page_size"]" when calling UnifiedATSAPIApi.get_ats_users, must be greater than or equal to 1.'
      end

      pattern = Regexp.new(/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?)?Z?$/)
      if @api_client.config.client_side_validation && !opts[:'updated_after'].nil? && opts[:'updated_after'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"updated_after\"]' when calling UnifiedATSAPIApi.get_ats_users, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/ats/users'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cursor'] = opts[:'cursor'] if !opts[:'cursor'].nil?
      query_params[:'page_size'] = opts[:'page_size'] if !opts[:'page_size'].nil?
      query_params[:'updated_after'] = opts[:'updated_after'] if !opts[:'updated_after'].nil?
      query_params[:'include_deleted'] = opts[:'include_deleted'] if !opts[:'include_deleted'].nil?
      query_params[:'ids'] = opts[:'ids'] if !opts[:'ids'].nil?
      query_params[:'remote_ids'] = opts[:'remote_ids'] if !opts[:'remote_ids'].nil?
      query_params[:'emails'] = opts[:'emails'] if !opts[:'emails'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetAtsUsersPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.get_ats_users",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#get_ats_users\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update interview
    # Update interview    <Warning>**Closed Beta Feature:** This endpoint is currently in closed beta. We're testing it with selected customers before its public release. If you're interested in learning more or getting early access, please reach out.</Warning>  
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The ID of the application
    # @param [Hash] opts the optional parameters
    # @option opts [PatchAtsApplicationsApplicationIdInterviewsRequestBody] :patch_ats_applications_application_id_interviews_request_body PATCH /ats/applications/:application_id/interviews Request body
    # @return [PatchAtsApplicationsApplicationIdInterviewsPositiveResponse]
    def patch_ats_applications_application_id_interviews(x_integration_id, application_id, opts = {})
      data, _status_code, _headers = patch_ats_applications_application_id_interviews_with_http_info(x_integration_id, application_id, opts)
      data
    end

    # Update interview
    # Update interview    &lt;Warning&gt;**Closed Beta Feature:** This endpoint is currently in closed beta. We&#39;re testing it with selected customers before its public release. If you&#39;re interested in learning more or getting early access, please reach out.&lt;/Warning&gt;  
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The ID of the application
    # @param [Hash] opts the optional parameters
    # @option opts [PatchAtsApplicationsApplicationIdInterviewsRequestBody] :patch_ats_applications_application_id_interviews_request_body PATCH /ats/applications/:application_id/interviews Request body
    # @return [Array<(PatchAtsApplicationsApplicationIdInterviewsPositiveResponse, Integer, Hash)>] PatchAtsApplicationsApplicationIdInterviewsPositiveResponse data, response status code and response headers
    def patch_ats_applications_application_id_interviews_with_http_info(x_integration_id, application_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.patch_ats_applications_application_id_interviews ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.patch_ats_applications_application_id_interviews"
      end
      # verify the required parameter 'application_id' is set
      if @api_client.config.client_side_validation && application_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_id' when calling UnifiedATSAPIApi.patch_ats_applications_application_id_interviews"
      end
      # resource path
      local_var_path = '/ats/applications/{application_id}/interviews'.sub('{' + 'application_id' + '}', CGI.escape(application_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'patch_ats_applications_application_id_interviews_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PatchAtsApplicationsApplicationIdInterviewsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.patch_ats_applications_application_id_interviews",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#patch_ats_applications_application_id_interviews\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add attachment to application
    # Uploads an attachment file for the specified applicant.  <Warning>   If adding an attachment to an application is not supported by the integration, the attachment will be [added to the candidate](/ats/v1/post-candidates-candidate-id-attachments) instead.  </Warning>  <Note>   This endpoint requires the permission **Add attachments** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"application_id\": \"GRKdd9dibYKKCrmGRSMJf3wu\",   \"attachment\": {     \"name\": \"Frank Doe CV.txt\",     \"data\": \"SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=\",     \"type\": \"CV\",     \"content_type\": \"text/plain\"   },   \"remote_fields\": {} } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] POST /ats/applications/:application_id/attachments Parameter
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdAttachmentsRequestBody] :post_ats_applications_application_id_attachments_request_body POST /ats/applications/:application_id/attachments Request body
    # @return [PostAtsApplicationsApplicationIdAttachmentsPositiveResponse]
    def post_ats_applications_application_id_attachments(x_integration_id, application_id, opts = {})
      data, _status_code, _headers = post_ats_applications_application_id_attachments_with_http_info(x_integration_id, application_id, opts)
      data
    end

    # Add attachment to application
    # Uploads an attachment file for the specified applicant.  &lt;Warning&gt;   If adding an attachment to an application is not supported by the integration, the attachment will be [added to the candidate](/ats/v1/post-candidates-candidate-id-attachments) instead.  &lt;/Warning&gt;  &lt;Note&gt;   This endpoint requires the permission **Add attachments** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;application_id\&quot;: \&quot;GRKdd9dibYKKCrmGRSMJf3wu\&quot;,   \&quot;attachment\&quot;: {     \&quot;name\&quot;: \&quot;Frank Doe CV.txt\&quot;,     \&quot;data\&quot;: \&quot;SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4&#x3D;\&quot;,     \&quot;type\&quot;: \&quot;CV\&quot;,     \&quot;content_type\&quot;: \&quot;text/plain\&quot;   },   \&quot;remote_fields\&quot;: {} } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] POST /ats/applications/:application_id/attachments Parameter
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdAttachmentsRequestBody] :post_ats_applications_application_id_attachments_request_body POST /ats/applications/:application_id/attachments Request body
    # @return [Array<(PostAtsApplicationsApplicationIdAttachmentsPositiveResponse, Integer, Hash)>] PostAtsApplicationsApplicationIdAttachmentsPositiveResponse data, response status code and response headers
    def post_ats_applications_application_id_attachments_with_http_info(x_integration_id, application_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_applications_application_id_attachments ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_attachments"
      end
      # verify the required parameter 'application_id' is set
      if @api_client.config.client_side_validation && application_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_attachments"
      end
      # resource path
      local_var_path = '/ats/applications/{application_id}/attachments'.sub('{' + 'application_id' + '}', CGI.escape(application_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_applications_application_id_attachments_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsApplicationsApplicationIdAttachmentsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_applications_application_id_attachments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_applications_application_id_attachments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create interview
    # Create interview    <Warning>**Closed Beta Feature:** This endpoint is currently in closed beta. We're testing it with selected customers before its public release. If you're interested in learning more or getting early access, please reach out.</Warning>  
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The ID of the application
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdInterviewsRequestBody] :post_ats_applications_application_id_interviews_request_body POST /ats/applications/:application_id/interviews Request body
    # @return [PostAtsApplicationsApplicationIdInterviewsPositiveResponse]
    def post_ats_applications_application_id_interviews(x_integration_id, application_id, opts = {})
      data, _status_code, _headers = post_ats_applications_application_id_interviews_with_http_info(x_integration_id, application_id, opts)
      data
    end

    # Create interview
    # Create interview    &lt;Warning&gt;**Closed Beta Feature:** This endpoint is currently in closed beta. We&#39;re testing it with selected customers before its public release. If you&#39;re interested in learning more or getting early access, please reach out.&lt;/Warning&gt;  
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The ID of the application
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdInterviewsRequestBody] :post_ats_applications_application_id_interviews_request_body POST /ats/applications/:application_id/interviews Request body
    # @return [Array<(PostAtsApplicationsApplicationIdInterviewsPositiveResponse, Integer, Hash)>] PostAtsApplicationsApplicationIdInterviewsPositiveResponse data, response status code and response headers
    def post_ats_applications_application_id_interviews_with_http_info(x_integration_id, application_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_applications_application_id_interviews ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_interviews"
      end
      # verify the required parameter 'application_id' is set
      if @api_client.config.client_side_validation && application_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_interviews"
      end
      # resource path
      local_var_path = '/ats/applications/{application_id}/interviews'.sub('{' + 'application_id' + '}', CGI.escape(application_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_applications_application_id_interviews_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsApplicationsApplicationIdInterviewsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_applications_application_id_interviews",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_applications_application_id_interviews\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add note to application
    # Add a note to an application.  Add extra information to an application. This can be any extra text information you want to add to an application.  <Note>   This endpoint requires the permission **Add notes** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"content\": \"A new message from the candidate is available in YourChat!\",   \"content_type\": \"PLAIN_TEXT\",   \"remote_fields\": {} } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to create the note for.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdNotesRequestBody] :post_ats_applications_application_id_notes_request_body POST /ats/applications/:application_id/notes Request body
    # @return [PostAtsApplicationsApplicationIdNotesPositiveResponse]
    def post_ats_applications_application_id_notes(x_integration_id, application_id, opts = {})
      data, _status_code, _headers = post_ats_applications_application_id_notes_with_http_info(x_integration_id, application_id, opts)
      data
    end

    # Add note to application
    # Add a note to an application.  Add extra information to an application. This can be any extra text information you want to add to an application.  &lt;Note&gt;   This endpoint requires the permission **Add notes** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;content\&quot;: \&quot;A new message from the candidate is available in YourChat!\&quot;,   \&quot;content_type\&quot;: \&quot;PLAIN_TEXT\&quot;,   \&quot;remote_fields\&quot;: {} } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to create the note for.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdNotesRequestBody] :post_ats_applications_application_id_notes_request_body POST /ats/applications/:application_id/notes Request body
    # @return [Array<(PostAtsApplicationsApplicationIdNotesPositiveResponse, Integer, Hash)>] PostAtsApplicationsApplicationIdNotesPositiveResponse data, response status code and response headers
    def post_ats_applications_application_id_notes_with_http_info(x_integration_id, application_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_applications_application_id_notes ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_notes"
      end
      # verify the required parameter 'application_id' is set
      if @api_client.config.client_side_validation && application_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_notes"
      end
      # resource path
      local_var_path = '/ats/applications/{application_id}/notes'.sub('{' + 'application_id' + '}', CGI.escape(application_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_applications_application_id_notes_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsApplicationsApplicationIdNotesPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_applications_application_id_notes",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_applications_application_id_notes\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Reject application
    # Rejects an application with a provided reason.  Rejects an application with a provided reason. Optionally, you can provide a free text note. You can get the list of rejection reasons with our [Get rejection reasons endpoint](/ats/v1/get-rejection-reasons).  <Note>   This endpoint requires the permission **Reject applications** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"rejection_reason_id\": \"3PJ8PZhZZa1eEdd2DtPNtVup\",   \"note\": \"Candidate was a great culture fit but didn't bring the hard skills we need.\",   \"remote_fields\": {} } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to reject.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdRejectRequestBody] :post_ats_applications_application_id_reject_request_body POST /ats/applications/:application_id/reject Request body
    # @return [PostAtsApplicationsApplicationIdRejectPositiveResponse]
    def post_ats_applications_application_id_reject(x_integration_id, application_id, opts = {})
      data, _status_code, _headers = post_ats_applications_application_id_reject_with_http_info(x_integration_id, application_id, opts)
      data
    end

    # Reject application
    # Rejects an application with a provided reason.  Rejects an application with a provided reason. Optionally, you can provide a free text note. You can get the list of rejection reasons with our [Get rejection reasons endpoint](/ats/v1/get-rejection-reasons).  &lt;Note&gt;   This endpoint requires the permission **Reject applications** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;rejection_reason_id\&quot;: \&quot;3PJ8PZhZZa1eEdd2DtPNtVup\&quot;,   \&quot;note\&quot;: \&quot;Candidate was a great culture fit but didn&#39;t bring the hard skills we need.\&quot;,   \&quot;remote_fields\&quot;: {} } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to reject.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdRejectRequestBody] :post_ats_applications_application_id_reject_request_body POST /ats/applications/:application_id/reject Request body
    # @return [Array<(PostAtsApplicationsApplicationIdRejectPositiveResponse, Integer, Hash)>] PostAtsApplicationsApplicationIdRejectPositiveResponse data, response status code and response headers
    def post_ats_applications_application_id_reject_with_http_info(x_integration_id, application_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_applications_application_id_reject ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_reject"
      end
      # verify the required parameter 'application_id' is set
      if @api_client.config.client_side_validation && application_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_reject"
      end
      # resource path
      local_var_path = '/ats/applications/{application_id}/reject'.sub('{' + 'application_id' + '}', CGI.escape(application_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_applications_application_id_reject_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsApplicationsApplicationIdRejectPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_applications_application_id_reject",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_applications_application_id_reject\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add result link to application
    # Add a result link to an application.  This can, for example, be used to link a candidate back to a test result/assessment in your application. As not all ATS tools have a \"result link\" feature, we sometimes repurpose other fields to expose it.  <Note>   This endpoint requires the permission **Add result links** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"application_id\": \"8Xi6iZrwusZqJmDGXs49GBmJ\",   \"label\": \"Assessment Result\",   \"url\": \"https://example.com/test-results/5BtP1WC1UboS7CF3yxjKcvjG\",   \"details\": {     \"custom_field_name_prefix\": \"Acme:\",     \"attributes\": [       {         \"key\": \"Score\",         \"value\": \"100%\"       },       {         \"key\": \"Time\",         \"value\": \"2:30h\"       }     ]   },   \"remote_fields\": {} } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to create the link for.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdResultLinksRequestBody] :post_ats_applications_application_id_result_links_request_body POST /ats/applications/:application_id/result-links Request body
    # @return [PostAtsApplicationsApplicationIdResultLinksPositiveResponse]
    def post_ats_applications_application_id_result_links(x_integration_id, application_id, opts = {})
      data, _status_code, _headers = post_ats_applications_application_id_result_links_with_http_info(x_integration_id, application_id, opts)
      data
    end

    # Add result link to application
    # Add a result link to an application.  This can, for example, be used to link a candidate back to a test result/assessment in your application. As not all ATS tools have a \&quot;result link\&quot; feature, we sometimes repurpose other fields to expose it.  &lt;Note&gt;   This endpoint requires the permission **Add result links** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;application_id\&quot;: \&quot;8Xi6iZrwusZqJmDGXs49GBmJ\&quot;,   \&quot;label\&quot;: \&quot;Assessment Result\&quot;,   \&quot;url\&quot;: \&quot;https://example.com/test-results/5BtP1WC1UboS7CF3yxjKcvjG\&quot;,   \&quot;details\&quot;: {     \&quot;custom_field_name_prefix\&quot;: \&quot;Acme:\&quot;,     \&quot;attributes\&quot;: [       {         \&quot;key\&quot;: \&quot;Score\&quot;,         \&quot;value\&quot;: \&quot;100%\&quot;       },       {         \&quot;key\&quot;: \&quot;Time\&quot;,         \&quot;value\&quot;: \&quot;2:30h\&quot;       }     ]   },   \&quot;remote_fields\&quot;: {} } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to create the link for.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsApplicationsApplicationIdResultLinksRequestBody] :post_ats_applications_application_id_result_links_request_body POST /ats/applications/:application_id/result-links Request body
    # @return [Array<(PostAtsApplicationsApplicationIdResultLinksPositiveResponse, Integer, Hash)>] PostAtsApplicationsApplicationIdResultLinksPositiveResponse data, response status code and response headers
    def post_ats_applications_application_id_result_links_with_http_info(x_integration_id, application_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_applications_application_id_result_links ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_result_links"
      end
      # verify the required parameter 'application_id' is set
      if @api_client.config.client_side_validation && application_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_id' when calling UnifiedATSAPIApi.post_ats_applications_application_id_result_links"
      end
      # resource path
      local_var_path = '/ats/applications/{application_id}/result-links'.sub('{' + 'application_id' + '}', CGI.escape(application_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_applications_application_id_result_links_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsApplicationsApplicationIdResultLinksPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_applications_application_id_result_links",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_applications_application_id_result_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create candidate
    # Create a new candidate and application for the specified job.  <Warning>       **We recommend using the [Create application](/ats/v1/post-jobs-job-id-applications) endpoint instead.**        We realized that in practice it was always more about creating _applications_ instead of _candidates_, so we created a new, more aptly named one that you should use instead: [Create application](/ats/v1/post-jobs-job-id-applications)        Using it also has the benefit that we return the newly created applicant at the root level, so you can easily store its ID.     </Warning>  <Note>   This endpoint requires the permission **Create applications and candidates** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"candidate\": {     \"first_name\": \"Frank\",     \"last_name\": \"Doe\",     \"company\": \"Acme Inc.\",     \"title\": \"Head of Integrations\",     \"email_address\": \"frank.doe@example.com\",     \"phone_number\": \"+1-541-754-3010\",     \"gender\": \"MALE\",     \"salary_expectations\": {       \"amount\": 100000,       \"period\": \"YEAR\"     },     \"availability_date\": \"2021-01-01\",     \"location\": {       \"city\": \"New York\",       \"country\": \"US\",       \"state\": \"NY\"     },     \"social_links\": [       {         \"url\": \"https://www.linkedin.com/in/frank-doe-123456789/\"       },       {         \"url\": \"https://twitter.com/frankdoe\"       }     ]   },   \"application\": {     \"job_id\": \"BDpgnpZ148nrGh4mYHNxJBgx\",     \"stage_id\": \"8x3YKRDcuRnwShdh96ShBNn1\"   },   \"attachments\": [     {       \"name\": \"Frank Doe CV.txt\",       \"data\": \"SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=\",       \"type\": \"CV\",       \"content_type\": \"text/plain\"     }   ],   \"screening_question_answers\": [     {       \"question_id\": \"3phFBNXRweGnDmsU9o2vdPuQ\",       \"answer\": \"Yes\"     },     {       \"question_id\": \"EYJjhMQT3LtVKXnTbnRT8s6U\",       \"answer\": [         \"GUzE666zfyjeoCJX6A8n7wh6\",         \"5WPHzzKAv8cx97KtHRUV96U8\",         \"7yZfKGzWigXxxRTygqAfHvyE\"       ]     }   ],   \"remote_fields\": {} } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsCandidatesRequestBody] :post_ats_candidates_request_body POST /ats/candidates Request body
    # @return [PostAtsCandidatesPositiveResponse]
    def post_ats_candidates(x_integration_id, opts = {})
      data, _status_code, _headers = post_ats_candidates_with_http_info(x_integration_id, opts)
      data
    end

    # Create candidate
    # Create a new candidate and application for the specified job.  &lt;Warning&gt;       **We recommend using the [Create application](/ats/v1/post-jobs-job-id-applications) endpoint instead.**        We realized that in practice it was always more about creating _applications_ instead of _candidates_, so we created a new, more aptly named one that you should use instead: [Create application](/ats/v1/post-jobs-job-id-applications)        Using it also has the benefit that we return the newly created applicant at the root level, so you can easily store its ID.     &lt;/Warning&gt;  &lt;Note&gt;   This endpoint requires the permission **Create applications and candidates** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;candidate\&quot;: {     \&quot;first_name\&quot;: \&quot;Frank\&quot;,     \&quot;last_name\&quot;: \&quot;Doe\&quot;,     \&quot;company\&quot;: \&quot;Acme Inc.\&quot;,     \&quot;title\&quot;: \&quot;Head of Integrations\&quot;,     \&quot;email_address\&quot;: \&quot;frank.doe@example.com\&quot;,     \&quot;phone_number\&quot;: \&quot;+1-541-754-3010\&quot;,     \&quot;gender\&quot;: \&quot;MALE\&quot;,     \&quot;salary_expectations\&quot;: {       \&quot;amount\&quot;: 100000,       \&quot;period\&quot;: \&quot;YEAR\&quot;     },     \&quot;availability_date\&quot;: \&quot;2021-01-01\&quot;,     \&quot;location\&quot;: {       \&quot;city\&quot;: \&quot;New York\&quot;,       \&quot;country\&quot;: \&quot;US\&quot;,       \&quot;state\&quot;: \&quot;NY\&quot;     },     \&quot;social_links\&quot;: [       {         \&quot;url\&quot;: \&quot;https://www.linkedin.com/in/frank-doe-123456789/\&quot;       },       {         \&quot;url\&quot;: \&quot;https://twitter.com/frankdoe\&quot;       }     ]   },   \&quot;application\&quot;: {     \&quot;job_id\&quot;: \&quot;BDpgnpZ148nrGh4mYHNxJBgx\&quot;,     \&quot;stage_id\&quot;: \&quot;8x3YKRDcuRnwShdh96ShBNn1\&quot;   },   \&quot;attachments\&quot;: [     {       \&quot;name\&quot;: \&quot;Frank Doe CV.txt\&quot;,       \&quot;data\&quot;: \&quot;SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4&#x3D;\&quot;,       \&quot;type\&quot;: \&quot;CV\&quot;,       \&quot;content_type\&quot;: \&quot;text/plain\&quot;     }   ],   \&quot;screening_question_answers\&quot;: [     {       \&quot;question_id\&quot;: \&quot;3phFBNXRweGnDmsU9o2vdPuQ\&quot;,       \&quot;answer\&quot;: \&quot;Yes\&quot;     },     {       \&quot;question_id\&quot;: \&quot;EYJjhMQT3LtVKXnTbnRT8s6U\&quot;,       \&quot;answer\&quot;: [         \&quot;GUzE666zfyjeoCJX6A8n7wh6\&quot;,         \&quot;5WPHzzKAv8cx97KtHRUV96U8\&quot;,         \&quot;7yZfKGzWigXxxRTygqAfHvyE\&quot;       ]     }   ],   \&quot;remote_fields\&quot;: {} } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsCandidatesRequestBody] :post_ats_candidates_request_body POST /ats/candidates Request body
    # @return [Array<(PostAtsCandidatesPositiveResponse, Integer, Hash)>] PostAtsCandidatesPositiveResponse data, response status code and response headers
    def post_ats_candidates_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_candidates ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_candidates"
      end
      # resource path
      local_var_path = '/ats/candidates'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_candidates_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsCandidatesPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_candidates",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_candidates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add attachment to candidate
    # Uploads an attachment file for the specified candidate.  <Warning>   **We recommend using the [add attachment to application](/ats/v1/post-applications-application-id-attachments) endpoint instead.**    We realized that in practice it was always more about adding attachments to _applications_ instead of _candidates_, so we created a new, more aptly named one that you should use instead: [add attachment to application](/ats/v1/post-applications-application-id-attachments)   </Warning>  <Note>   This endpoint requires the permission **Add attachments** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"candidate_id\": \"GRKdd9dibYKKCrmGRSMJf3wu\",   \"attachment\": {     \"name\": \"Frank Doe CV.txt\",     \"data\": \"SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=\",     \"type\": \"CV\",     \"content_type\": \"text/plain\"   } } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to add the attachment to.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsCandidatesCandidateIdAttachmentsRequestBody] :post_ats_candidates_candidate_id_attachments_request_body POST /ats/candidates/:candidate_id/attachments Request body
    # @return [PostAtsCandidatesCandidateIdAttachmentsPositiveResponse]
    def post_ats_candidates_candidate_id_attachments(x_integration_id, candidate_id, opts = {})
      data, _status_code, _headers = post_ats_candidates_candidate_id_attachments_with_http_info(x_integration_id, candidate_id, opts)
      data
    end

    # Add attachment to candidate
    # Uploads an attachment file for the specified candidate.  &lt;Warning&gt;   **We recommend using the [add attachment to application](/ats/v1/post-applications-application-id-attachments) endpoint instead.**    We realized that in practice it was always more about adding attachments to _applications_ instead of _candidates_, so we created a new, more aptly named one that you should use instead: [add attachment to application](/ats/v1/post-applications-application-id-attachments)   &lt;/Warning&gt;  &lt;Note&gt;   This endpoint requires the permission **Add attachments** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;candidate_id\&quot;: \&quot;GRKdd9dibYKKCrmGRSMJf3wu\&quot;,   \&quot;attachment\&quot;: {     \&quot;name\&quot;: \&quot;Frank Doe CV.txt\&quot;,     \&quot;data\&quot;: \&quot;SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4&#x3D;\&quot;,     \&quot;type\&quot;: \&quot;CV\&quot;,     \&quot;content_type\&quot;: \&quot;text/plain\&quot;   } } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to add the attachment to.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsCandidatesCandidateIdAttachmentsRequestBody] :post_ats_candidates_candidate_id_attachments_request_body POST /ats/candidates/:candidate_id/attachments Request body
    # @return [Array<(PostAtsCandidatesCandidateIdAttachmentsPositiveResponse, Integer, Hash)>] PostAtsCandidatesCandidateIdAttachmentsPositiveResponse data, response status code and response headers
    def post_ats_candidates_candidate_id_attachments_with_http_info(x_integration_id, candidate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_candidates_candidate_id_attachments ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_candidates_candidate_id_attachments"
      end
      # verify the required parameter 'candidate_id' is set
      if @api_client.config.client_side_validation && candidate_id.nil?
        fail ArgumentError, "Missing the required parameter 'candidate_id' when calling UnifiedATSAPIApi.post_ats_candidates_candidate_id_attachments"
      end
      # resource path
      local_var_path = '/ats/candidates/{candidate_id}/attachments'.sub('{' + 'candidate_id' + '}', CGI.escape(candidate_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_candidates_candidate_id_attachments_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsCandidatesCandidateIdAttachmentsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_candidates_candidate_id_attachments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_candidates_candidate_id_attachments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add result link to candidate
    # Add a result link to a candidate.  <Warning>   **We recommend to use [add result link to application](/ats/v1/post-applications-application-id-result-links) instead.**    This can, for example, be used to link a candidate back to a test result/assessment in your application. As not all ATS tools have a \"result link\" feature, we sometimes repurpose other fields to expose it.    </Warning>     <Note>   This endpoint requires the permission **Add result links** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"label\": \"Assessment Result\",   \"url\": \"https://example.com/test-results/5BtP1WC1UboS7CF3yxjKcvjG\",   \"details\": {     \"custom_field_name_prefix\": \"Acme:\",     \"attributes\": [       {         \"key\": \"Score\",         \"value\": \"100%\"       },       {         \"key\": \"Time\",         \"value\": \"2:30h\"       }     ]   },   \"remote_fields\": {} } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to add the result link to.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsCandidatesCandidateIdResultLinksRequestBody] :post_ats_candidates_candidate_id_result_links_request_body POST /ats/candidates/:candidate_id/result-links Request body
    # @return [PostAtsCandidatesCandidateIdResultLinksPositiveResponse]
    def post_ats_candidates_candidate_id_result_links(x_integration_id, candidate_id, opts = {})
      data, _status_code, _headers = post_ats_candidates_candidate_id_result_links_with_http_info(x_integration_id, candidate_id, opts)
      data
    end

    # Add result link to candidate
    # Add a result link to a candidate.  &lt;Warning&gt;   **We recommend to use [add result link to application](/ats/v1/post-applications-application-id-result-links) instead.**    This can, for example, be used to link a candidate back to a test result/assessment in your application. As not all ATS tools have a \&quot;result link\&quot; feature, we sometimes repurpose other fields to expose it.    &lt;/Warning&gt;     &lt;Note&gt;   This endpoint requires the permission **Add result links** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;label\&quot;: \&quot;Assessment Result\&quot;,   \&quot;url\&quot;: \&quot;https://example.com/test-results/5BtP1WC1UboS7CF3yxjKcvjG\&quot;,   \&quot;details\&quot;: {     \&quot;custom_field_name_prefix\&quot;: \&quot;Acme:\&quot;,     \&quot;attributes\&quot;: [       {         \&quot;key\&quot;: \&quot;Score\&quot;,         \&quot;value\&quot;: \&quot;100%\&quot;       },       {         \&quot;key\&quot;: \&quot;Time\&quot;,         \&quot;value\&quot;: \&quot;2:30h\&quot;       }     ]   },   \&quot;remote_fields\&quot;: {} } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to add the result link to.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsCandidatesCandidateIdResultLinksRequestBody] :post_ats_candidates_candidate_id_result_links_request_body POST /ats/candidates/:candidate_id/result-links Request body
    # @return [Array<(PostAtsCandidatesCandidateIdResultLinksPositiveResponse, Integer, Hash)>] PostAtsCandidatesCandidateIdResultLinksPositiveResponse data, response status code and response headers
    def post_ats_candidates_candidate_id_result_links_with_http_info(x_integration_id, candidate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_candidates_candidate_id_result_links ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_candidates_candidate_id_result_links"
      end
      # verify the required parameter 'candidate_id' is set
      if @api_client.config.client_side_validation && candidate_id.nil?
        fail ArgumentError, "Missing the required parameter 'candidate_id' when calling UnifiedATSAPIApi.post_ats_candidates_candidate_id_result_links"
      end
      # resource path
      local_var_path = '/ats/candidates/{candidate_id}/result-links'.sub('{' + 'candidate_id' + '}', CGI.escape(candidate_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_candidates_candidate_id_result_links_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsCandidatesCandidateIdResultLinksPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_candidates_candidate_id_result_links",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_candidates_candidate_id_result_links\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add tag to candidate
    # Add a tag to a candidate.  Kombo takes care of creating the tag if required, finding out the right ID, and appending it to the list of tags.  <Note>   This endpoint requires the permission **Manage tags** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"tag\": {     \"name\": \"Excellent Fit\"   } } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to add the tag to.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsCandidatesCandidateIdTagsRequestBody] :post_ats_candidates_candidate_id_tags_request_body POST /ats/candidates/:candidate_id/tags Request body
    # @return [PostAtsCandidatesCandidateIdTagsPositiveResponse]
    def post_ats_candidates_candidate_id_tags(x_integration_id, candidate_id, opts = {})
      data, _status_code, _headers = post_ats_candidates_candidate_id_tags_with_http_info(x_integration_id, candidate_id, opts)
      data
    end

    # Add tag to candidate
    # Add a tag to a candidate.  Kombo takes care of creating the tag if required, finding out the right ID, and appending it to the list of tags.  &lt;Note&gt;   This endpoint requires the permission **Manage tags** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;tag\&quot;: {     \&quot;name\&quot;: \&quot;Excellent Fit\&quot;   } } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param candidate_id [String] The Kombo ID of the candidate you want to add the tag to.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsCandidatesCandidateIdTagsRequestBody] :post_ats_candidates_candidate_id_tags_request_body POST /ats/candidates/:candidate_id/tags Request body
    # @return [Array<(PostAtsCandidatesCandidateIdTagsPositiveResponse, Integer, Hash)>] PostAtsCandidatesCandidateIdTagsPositiveResponse data, response status code and response headers
    def post_ats_candidates_candidate_id_tags_with_http_info(x_integration_id, candidate_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_candidates_candidate_id_tags ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_candidates_candidate_id_tags"
      end
      # verify the required parameter 'candidate_id' is set
      if @api_client.config.client_side_validation && candidate_id.nil?
        fail ArgumentError, "Missing the required parameter 'candidate_id' when calling UnifiedATSAPIApi.post_ats_candidates_candidate_id_tags"
      end
      # resource path
      local_var_path = '/ats/candidates/{candidate_id}/tags'.sub('{' + 'candidate_id' + '}', CGI.escape(candidate_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_candidates_candidate_id_tags_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsCandidatesCandidateIdTagsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_candidates_candidate_id_tags",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_candidates_candidate_id_tags\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Import tracked application
    # Import tracked application  Retroactively import existing applications into Kombo's tracking system. This is particularly useful if you have enabled the 'sync only created applications' setting and want to start tracking applications that were created before using Kombo.  To import an application, you'll need to provide specific identifiers based on the ATS. The available `id_type` values are defined by Kombo based on the tool's API capabilities. Please reach out to Kombo support if you require further types to be supported.  Once imported, Kombo will automatically fetch and update the application's complete data during the next sync.  ### Example Request Body  ```json {   \"tracked_at\": \"2024-04-12T14:33:47.000Z\",   \"successfactors\": {     \"id_type\": \"application_remote_id\",     \"application_remote_id\": \"1224042\"   } } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsImportTrackedApplicationRequestBody] :post_ats_import_tracked_application_request_body POST /ats/import-tracked-application Request body
    # @return [PostAtsImportTrackedApplicationPositiveResponse]
    def post_ats_import_tracked_application(x_integration_id, opts = {})
      data, _status_code, _headers = post_ats_import_tracked_application_with_http_info(x_integration_id, opts)
      data
    end

    # Import tracked application
    # Import tracked application  Retroactively import existing applications into Kombo&#39;s tracking system. This is particularly useful if you have enabled the &#39;sync only created applications&#39; setting and want to start tracking applications that were created before using Kombo.  To import an application, you&#39;ll need to provide specific identifiers based on the ATS. The available &#x60;id_type&#x60; values are defined by Kombo based on the tool&#39;s API capabilities. Please reach out to Kombo support if you require further types to be supported.  Once imported, Kombo will automatically fetch and update the application&#39;s complete data during the next sync.  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;tracked_at\&quot;: \&quot;2024-04-12T14:33:47.000Z\&quot;,   \&quot;successfactors\&quot;: {     \&quot;id_type\&quot;: \&quot;application_remote_id\&quot;,     \&quot;application_remote_id\&quot;: \&quot;1224042\&quot;   } } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsImportTrackedApplicationRequestBody] :post_ats_import_tracked_application_request_body POST /ats/import-tracked-application Request body
    # @return [Array<(PostAtsImportTrackedApplicationPositiveResponse, Integer, Hash)>] PostAtsImportTrackedApplicationPositiveResponse data, response status code and response headers
    def post_ats_import_tracked_application_with_http_info(x_integration_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_import_tracked_application ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_import_tracked_application"
      end
      # resource path
      local_var_path = '/ats/import-tracked-application'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_import_tracked_application_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsImportTrackedApplicationPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_import_tracked_application",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_import_tracked_application\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create application
    # Create a new application and candidate for the specified job.  Visit our in-depth guides to learn more about:  - üåê [Setting the source of the application](/ats/features/implementation-guide/creating-applications#set-the-source-of-the-application)  - üìé [Uploading attachments with the application](/ats/features/implementation-guide/creating-applications#upload-attachments-with-the-application)  - ‚ôªÔ∏è [Retry behaviour](/ats/features/implementation-guide/creating-applications#retry-behaviour)  - ‚úèÔ∏è [Writing answers to screening questions](/ats/features/implementation-guide/creating-applications#write-answers-to-screening-questions)  - ‚ö†Ô∏è [Handling ATS-specific limitations](/ats/features/implementation-guide/creating-applications#handle-ats-specific-limitations)  <Note>   This endpoint requires the permission **Create applications and candidates** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"candidate\": {     \"first_name\": \"Frank\",     \"last_name\": \"Doe\",     \"company\": \"Acme Inc.\",     \"title\": \"Head of Integrations\",     \"email_address\": \"frank.doe@example.com\",     \"phone_number\": \"+1-541-754-3010\",     \"gender\": \"MALE\",     \"salary_expectations\": {       \"amount\": 100000,       \"period\": \"YEAR\"     },     \"availability_date\": \"2021-01-01\",     \"location\": {       \"city\": \"New York\",       \"country\": \"US\"     }   },   \"stage_id\": \"8x3YKRDcuRnwShdh96ShBNn1\",   \"attachments\": [     {       \"name\": \"Frank Doe CV.txt\",       \"data\": \"SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4=\",       \"type\": \"CV\",       \"content_type\": \"text/plain\"     }   ],   \"screening_question_answers\": [     {       \"question_id\": \"3phFBNXRweGnDmsU9o2vdPuQ\",       \"answer\": \"Yes\"     },     {       \"question_id\": \"EYJjhMQT3LtVKXnTbnRT8s6U\",       \"answer\": [         \"GUzE666zfyjeoCJX6A8n7wh6\",         \"5WPHzzKAv8cx97KtHRUV96U8\",         \"7yZfKGzWigXxxRTygqAfHvyE\"       ]     }   ],   \"remote_fields\": {} } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param job_id [String] The Kombo ID or Remote ID of the Job this candidate should apply for. If you want to use the ID of the integrated system (remote_id) you need to prefix the id with \&quot;remote:\&quot;. You can use the remote ID if you do not want to sync jobs.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsJobsJobIdApplicationsRequestBody] :post_ats_jobs_job_id_applications_request_body POST /ats/jobs/:job_id/applications Request body
    # @return [PostAtsJobsJobIdApplicationsPositiveResponse]
    def post_ats_jobs_job_id_applications(x_integration_id, job_id, opts = {})
      data, _status_code, _headers = post_ats_jobs_job_id_applications_with_http_info(x_integration_id, job_id, opts)
      data
    end

    # Create application
    # Create a new application and candidate for the specified job.  Visit our in-depth guides to learn more about:  - üåê [Setting the source of the application](/ats/features/implementation-guide/creating-applications#set-the-source-of-the-application)  - üìé [Uploading attachments with the application](/ats/features/implementation-guide/creating-applications#upload-attachments-with-the-application)  - ‚ôªÔ∏è [Retry behaviour](/ats/features/implementation-guide/creating-applications#retry-behaviour)  - ‚úèÔ∏è [Writing answers to screening questions](/ats/features/implementation-guide/creating-applications#write-answers-to-screening-questions)  - ‚ö†Ô∏è [Handling ATS-specific limitations](/ats/features/implementation-guide/creating-applications#handle-ats-specific-limitations)  &lt;Note&gt;   This endpoint requires the permission **Create applications and candidates** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;candidate\&quot;: {     \&quot;first_name\&quot;: \&quot;Frank\&quot;,     \&quot;last_name\&quot;: \&quot;Doe\&quot;,     \&quot;company\&quot;: \&quot;Acme Inc.\&quot;,     \&quot;title\&quot;: \&quot;Head of Integrations\&quot;,     \&quot;email_address\&quot;: \&quot;frank.doe@example.com\&quot;,     \&quot;phone_number\&quot;: \&quot;+1-541-754-3010\&quot;,     \&quot;gender\&quot;: \&quot;MALE\&quot;,     \&quot;salary_expectations\&quot;: {       \&quot;amount\&quot;: 100000,       \&quot;period\&quot;: \&quot;YEAR\&quot;     },     \&quot;availability_date\&quot;: \&quot;2021-01-01\&quot;,     \&quot;location\&quot;: {       \&quot;city\&quot;: \&quot;New York\&quot;,       \&quot;country\&quot;: \&quot;US\&quot;     }   },   \&quot;stage_id\&quot;: \&quot;8x3YKRDcuRnwShdh96ShBNn1\&quot;,   \&quot;attachments\&quot;: [     {       \&quot;name\&quot;: \&quot;Frank Doe CV.txt\&quot;,       \&quot;data\&quot;: \&quot;SGkgdGhlcmUsIEtvbWJvIGlzIGN1cnJlbnRseSBoaXJpbmcgZW5naW5lZXJzIHRoYXQgbG92ZSB0byB3b3JrIG9uIGRldmVsb3BlciBwcm9kdWN0cy4&#x3D;\&quot;,       \&quot;type\&quot;: \&quot;CV\&quot;,       \&quot;content_type\&quot;: \&quot;text/plain\&quot;     }   ],   \&quot;screening_question_answers\&quot;: [     {       \&quot;question_id\&quot;: \&quot;3phFBNXRweGnDmsU9o2vdPuQ\&quot;,       \&quot;answer\&quot;: \&quot;Yes\&quot;     },     {       \&quot;question_id\&quot;: \&quot;EYJjhMQT3LtVKXnTbnRT8s6U\&quot;,       \&quot;answer\&quot;: [         \&quot;GUzE666zfyjeoCJX6A8n7wh6\&quot;,         \&quot;5WPHzzKAv8cx97KtHRUV96U8\&quot;,         \&quot;7yZfKGzWigXxxRTygqAfHvyE\&quot;       ]     }   ],   \&quot;remote_fields\&quot;: {} } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param job_id [String] The Kombo ID or Remote ID of the Job this candidate should apply for. If you want to use the ID of the integrated system (remote_id) you need to prefix the id with \&quot;remote:\&quot;. You can use the remote ID if you do not want to sync jobs.
    # @param [Hash] opts the optional parameters
    # @option opts [PostAtsJobsJobIdApplicationsRequestBody] :post_ats_jobs_job_id_applications_request_body POST /ats/jobs/:job_id/applications Request body
    # @return [Array<(PostAtsJobsJobIdApplicationsPositiveResponse, Integer, Hash)>] PostAtsJobsJobIdApplicationsPositiveResponse data, response status code and response headers
    def post_ats_jobs_job_id_applications_with_http_info(x_integration_id, job_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.post_ats_jobs_job_id_applications ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.post_ats_jobs_job_id_applications"
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling UnifiedATSAPIApi.post_ats_jobs_job_id_applications"
      end
      # resource path
      local_var_path = '/ats/jobs/{job_id}/applications'.sub('{' + 'job_id' + '}', CGI.escape(job_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_ats_jobs_job_id_applications_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAtsJobsJobIdApplicationsPositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.post_ats_jobs_job_id_applications",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#post_ats_jobs_job_id_applications\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Move application to stage
    # Moves an application to a specified stage. Use job-specific stages from GET /jobs, not the deprecated /application-stages endpoint.  <Note>   This endpoint requires the permission **Set application stage** to be enabled in [your scope config](/scopes). </Note>  ### Example Request Body  ```json {   \"stage_id\": \"3PJ8PZhZZa1eEdd2DtPNtVup\" } ```
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to move to a different stage.
    # @param [Hash] opts the optional parameters
    # @option opts [PutAtsApplicationsApplicationIdStageRequestBody] :put_ats_applications_application_id_stage_request_body PUT /ats/applications/:application_id/stage Request body
    # @return [PutAtsApplicationsApplicationIdStagePositiveResponse]
    def put_ats_applications_application_id_stage(x_integration_id, application_id, opts = {})
      data, _status_code, _headers = put_ats_applications_application_id_stage_with_http_info(x_integration_id, application_id, opts)
      data
    end

    # Move application to stage
    # Moves an application to a specified stage. Use job-specific stages from GET /jobs, not the deprecated /application-stages endpoint.  &lt;Note&gt;   This endpoint requires the permission **Set application stage** to be enabled in [your scope config](/scopes). &lt;/Note&gt;  ### Example Request Body  &#x60;&#x60;&#x60;json {   \&quot;stage_id\&quot;: \&quot;3PJ8PZhZZa1eEdd2DtPNtVup\&quot; } &#x60;&#x60;&#x60;
    # @param x_integration_id [String] ID of the integration you want to interact with.
    # @param application_id [String] The Kombo ID of the application you want to move to a different stage.
    # @param [Hash] opts the optional parameters
    # @option opts [PutAtsApplicationsApplicationIdStageRequestBody] :put_ats_applications_application_id_stage_request_body PUT /ats/applications/:application_id/stage Request body
    # @return [Array<(PutAtsApplicationsApplicationIdStagePositiveResponse, Integer, Hash)>] PutAtsApplicationsApplicationIdStagePositiveResponse data, response status code and response headers
    def put_ats_applications_application_id_stage_with_http_info(x_integration_id, application_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UnifiedATSAPIApi.put_ats_applications_application_id_stage ...'
      end
      # verify the required parameter 'x_integration_id' is set
      if @api_client.config.client_side_validation && x_integration_id.nil?
        fail ArgumentError, "Missing the required parameter 'x_integration_id' when calling UnifiedATSAPIApi.put_ats_applications_application_id_stage"
      end
      # verify the required parameter 'application_id' is set
      if @api_client.config.client_side_validation && application_id.nil?
        fail ArgumentError, "Missing the required parameter 'application_id' when calling UnifiedATSAPIApi.put_ats_applications_application_id_stage"
      end
      # resource path
      local_var_path = '/ats/applications/{application_id}/stage'.sub('{' + 'application_id' + '}', CGI.escape(application_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'X-Integration-Id'] = x_integration_id

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'put_ats_applications_application_id_stage_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'PutAtsApplicationsApplicationIdStagePositiveResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"UnifiedATSAPIApi.put_ats_applications_application_id_stage",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UnifiedATSAPIApi#put_ats_applications_application_id_stage\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
